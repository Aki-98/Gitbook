{"./":{"url":"./","title":"English","keywords":"","body":" 文件索引 SUMMARY 索引结束 Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:30:50 "},"English/":{"url":"English/","title":"[engineering practice]","keywords":"","body":" 文件索引 README 索引结束 Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:30:50 "},"English/[Engineering Practice]/Setting Up Gitbook Full Process and Pitfall Record.html":{"url":"English/[Engineering Practice]/Setting Up Gitbook Full Process and Pitfall Record.html","title":"Setting up gitbook full process and pitfall record","keywords":"","body":"Here is the translation of the provided text into English: All Python programs mentioned here are written by myself. Since I only considered my own needs and didn't think about other situations, it would be better to modify them according to your own situation if you want to copy and use them. Code location: https://github.com/Leah-98/Python-Automation/tree/main/Gitbook The biggest advantage of processing your notes into Gitbook is the ability to search globally. Step 1: Prepare the MD Note Repository 1. Convert all files to MD or reference them in MD files Gitbook can only render Markdown pages. Some of my old notes were exported from Evernote and Youdao Cloud, which were in web format. I converted the web format to PDF and referenced it in the README.md folder (append_other_files_to_readme.py). There are also some scattered TXT notes, which I directly changed the suffix to MD (txt_to_md.py). 2. Place the images referenced in MD in a subfolder at the same level as the MD file, and name the subfolder after the MD file with \"_imgs\" appended The image references in the previous notes were messy. Some were web images, and some were absolute paths written by Typora. When operating on the same note repository on different computers, the absolute paths were inconsistent. Some were placed in the \"imgs\" folder with relative paths, but the \"imgs\" folder was located in various positions within the note repository, making it messy. I used a Python program to unify and place them in a subfolder at the same level as the MD file, naming the subfolder after the MD file with \"_imgs\" appended, and rewriting the image references in MD to relative paths (reformat_imgs.py). Also, many of my book excerpts are directly taken from physical books. The phone photos are too large and need to be compressed (compress_pictures.py). 3. Generate SUMMARY.md Arrange all MD files and write them in SUMMARY.md. If it's a subfolder and doesn't have README.md, create one yourself (generate_summary.py). This is better than gitbook init, which has various bugs and cannot generate a summary based on all MD files. Step 2: Prepare the Gitbook Setup Environment I followed some online tutorials and encountered many issues. This tutorial is too simple. You can take a look to get a general idea, but don't follow its procedures: https://tonydeng.github.io/gitbook-zh/ This one is more detailed and better: https://1927344728.github.io/fed-knowledge/tools/Gitbook/ 0. Preparing for pitfalls At first, I directly downloaded and installed from the official website: Official website: https://nodejs.org/en However, the version from the official website (v18.x) is too new, causing various adaptation issues with gitbook. Later, I downgraded to v.10.x to use gitbook normally. I encountered an error when installing gitbook-cli after installing v18.x version of nodejs and calling gitbook init in the command line: /home/travis/.nvm/versions/node/v12.18.3/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /home/travis/.nvm/versions/node/v12.18.3/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:169:5) Solution: https://stackoverflow.com/questions/64211386/gitbook-cli-install-error-typeerror-cb-apply-is-not-a-function-inside-graceful You need to update the graceful-fs version. When I tried to update with npm, I encountered another issue where any command would result in an error \"ERR! Cannot read property 'insert' of undefined\". Solution: https://github.com/npm/cli/issues/4876 You need to change the mirror to https://registry.npmmirror.com. If you also need to set a proxy, there is a tutorial here: Setting npm proxy: https://blog.csdn.net/yanzi1225627/article/details/80247758 After updating, calling any gitbook command resulted in no response, no error, and no information. The local directory remained unchanged. I then downgraded nodejs to 10.x. During this process, there was also an issue that gitbook and gitbook-cli could not coexist. You need to uninstall gitbook to use gitbook-cli (the command-line tool for gitbook). After installing gitbook-cli, the first time you call the gitbook command, like checking the version with gitbook -V, gitbook-cli will install the corresponding version of gitbook. Since I got stuck at the \"install gitbook\" step every time I called the gitbook command and checked online for a solution, I found that you can clone gitbook's github repository and then install and link it yourself: git clone https://github.com/GitbookIO/gitbook.git cd gitbook npm install npm link Firstly, the instructions in the gitbook repository say to install with bun instead of npm. Secondly, this installation is equivalent to npm install gitbook, which conflicts with gitbook-cli. Therefore, this method is incorrect. Here is the correct method: 1. Install nvm (Node.js version manager) and Node.js v10.x Choose one based on your system: curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash bash Copy code wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash Install Node.js v10.x and use it: nvm install 10 nvm use 10 I also encountered an issue here. In the above steps, the npm version compatible with Node.js v10.x will be installed. However, I previously used v18.x. After switching to Node.js v10.x, the npm version did not change. Any npm command would result in an error. Later, I switched back to v18, uninstalled npm, which uninstalls the latest version of npm, and then switched to v10.x, allowing me to use the older version of npm. nvm use 18 npm uninstall npm -g The -g means the operation is carried out globally, which will be used in the following commands. 2. Install and use gitbook-cli & gitbook npm install gitbook-cli -g The npm install -g command is used to globally install Node.js modules. This means the installed modules will be placed in a specific directory, usually the global node_modules directory of your system, not in the node_modules directory of the current project. If you don't use the -g (global) parameter in the npm install command, the command will install the specified package in the node_modules folder of the current project, not in the global environment. gitbook -V Check the gitbook version. The first time you call any gitbook command, it will attempt to install gitbook. Running gitbook -V again will show the versions of gitbook-cli and gitbook. Note: Do not install gitbook with npm install gitbook directly; use gitbook-cli instead. 3. Preview the Gitbook website and make adjustments Switch the command line to the root directory of your MD source files and run the following command to automatically generate README.md and SUMMARY.md: gitbook init Note: Do not include the character \"#\" in the directory names and filenames under the MD files, meaning the generated SUMMARY.md should not contain the \"#\" character. If it does, it will cause the links in the gitbook page's left navigation bar to not work. Also, do not have consecutive curly braces in the MD files, like . Related instructions: https://wkcom.gitee.io/gitbook%E7%9A%84%E4%BD%BF%E7%94%A8/3%E3%80%81gitbook%E8%BF%9E%E7%BB%AD%E5%A4%A7%E6%8B%AC%E5%8F%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html Adding a space between the curly braces will resolve the issue. Preview the gitbook website: gitbook server Open the local port in the browser to view the page: http://localhost:4000/ Step 3: Set up .io online website There are many solutions; I chose to directly upload the static website to Github. Generate the gitbook static website, run the following command in the root directory of your MD source files: gitbook build This will generate a _book directory, containing the static website code. As long as the repository has a gh-pages branch, you can access Gitbook Pages with the following link: https://githubusername.github.io/reponame So the steps are: Create an empty Github repository. Check out a gh-pages branch, upload the static website. I need multiple gitbooks, so I created a subfolder in the root directory and uploaded the corresponding static website in this subfolder. Then, I can access multiple Gitbooks with the following paths: https://githubusername.github.io/reponame/subfoldername1 https://githubusername.github.io/reponame/subfoldername2 Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:24:40 "},"English/[Problem Solving]/The program packaged with PyInstaller that depends on apkutils cannot run.html":{"url":"English/[Problem Solving]/The program packaged with PyInstaller that depends on apkutils cannot run.html","title":"The program packaged with pyinstaller that depends on apkutils cannot run","keywords":"","body":"When running the exe, the following error occurs: Traceback (most recent call last): File \"create_release_jira.py\", line 47, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"submit_gerrit.py\", line 48, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"mandroid.py\", line 1, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\__init__.py\", line 1, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\apk.py\", line 12, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\axml\\__init__.py\", line 12, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\axml\\public.py\", line 22, in Exception: need to copy the sdk/platforms/android-?/data/res/values/public.xml here [6428] Failed to execute script 'create_release_jira' due to unhandled exception! The error message to focus on is: Exception: need to copy the sdk/platforms/android-?/data/res/values/public.xml here Information found online: https://github.com/Nuitka/Nuitka/issues/2289 The issue was resolved by adding a custom YAML configuration: - module-name: \"apkutils.axml\" data-files: patterns: - \"public.xml\" This indicates that the issue is due to apkutils being unable to find the public.xml. You can find the public.xml file in the local site-packages directory, as this file is a dependency of apkutils. The error is raised by public.py, which expects the public.xml file to be in the same path. Although PyInstaller does not support YAML configuration, the same effect can be achieved using the --add-data command. You can add the configuration in the PyInstaller command as follows: pyinstaller --add-data=\"F:\\.dev\\PYTHON\\Lib\\site-packages\\apkutils\\axml\\public.xml;apkutils/axml\" py_source_file.py Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-06 16:50:09 "},"English/[Source Code Reading]/[PMS] Why do downgraded system pre-installed applications revert after a reboot.html":{"url":"English/[Source Code Reading]/[PMS] Why do downgraded system pre-installed applications revert after a reboot.html","title":"[pms] why do downgraded system pre-installed applications revert after a reboot","keywords":"","body":"Background System pre-installed applications are stored in the /system partition. These applications are typically marked as read-only, and their versions are determined by system updates. However, during runtime, users may install newer versions of these system pre-installed applications (stored in the /data partition) or even downgrade them to versions lower than those in the /system partition. However, after a system reboot, if the version in the /data partition is lower than the version in the /system partition, the system will automatically revert to the version in the /system partition. Code Explanation The relevant source code can be found in frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java at Line 12162 ~ 12186: java复制代码// Compare VersionCode, if the VersionCode in /data is lower, execute this branch if (isSystemPkgBetter) { // The version of the application on /system is greater than the version on // /data. Switch back to the application on /system. // It's safe to assume the application on /system will correctly scan. If not, // there won't be a working copy of the application. synchronized (mLock) { // just remove the loaded entries from package lists mPackages.remove(pkgSetting.name); } logCriticalInfo(Log.WARN, \"System package updated;\" + \" name: \" + pkgSetting.name + \"; \" + pkgSetting.versionCode + \" --> \" + parsedPackage.getLongVersionCode() + \"; \" + pkgSetting.getPathString() + \" --> \" + parsedPackage.getPath()); final InstallArgs args = createInstallArgsForExisting( pkgSetting.getPathString(), getAppDexInstructionSets( pkgSetting.primaryCpuAbiString, pkgSetting.secondaryCpuAbiString)); args.cleanUpResourcesLI(); // Restore and enable the version in the `/system` partition synchronized (mLock) { mSettings.enableSystemPackageLPw(pkgSetting.name); } } Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-11-26 16:35:14 "},"English/[Source Code Reading]/[PM] What does passing 0 to PackageManager.getPackageInfo as a Flag mean.html":{"url":"English/[Source Code Reading]/[PM] What does passing 0 to PackageManager.getPackageInfo as a Flag mean.html","title":"[pm] what does passing 0 to packagemanager.getpackageinfo as a flag mean","keywords":"","body":"Environment Android SDK 31（Android 12） Background The issue arose from the following line of code in the project : PackageManager packageManager = context.getPackageManager(); PackageInfo info = packageManager.getPackageInfo(context.getPackageName(), 0); The 0 used as a flag parameter is flagged by PM Challenge, suggesting that Android constants should be used instead of integer values. I consulted the SDK documentation for clarification. SDK Documentation: Android Documentation： It's evident that there is no corresponding constant value for 0. There's no direct explanation of what passing 0 signifies, but it can be inferred that using other values and combinations of values could yield more information. Handling of Flags From the previous SDK documentation, it's clear that getPackageInfo is an abstract method, so its implementation is not in PackageManager. Printing context.getPackageManager().getClass().getName() reveals that the context.getPackageManager() method returns an ApplicationPackageManager object. Here, we cannot yet see how the Android system retrieves PackageInfo, but we can observe the handling of flags. ApplicationPackageManager.getPackageInfo(String packageName, int flags) --> 232 @Override 233 public PackageInfo getPackageInfoAsUser(String packageName, int flags, int userId) 234 throws NameNotFoundException { 235 PackageInfo pi = 236 getPackageInfoAsUserCached( 237 packageName, 238 updateFlagsForPackage(flags, userId), 239 userId); 240 if (pi == null) { 241 throw new NameNotFoundException(packageName); 242 } 243 return pi; 244 } ApplicationPackageManager.updateFlagsForPackage(int flags, int userId) 1829 /** 1830 * Update given flags when being used to request {@link PackageInfo}. 1831 */ 1832 private int updateFlagsForPackage(int flags, int userId) { 1833 if ((flags & (GET_ACTIVITIES | GET_RECEIVERS | GET_SERVICES | GET_PROVIDERS)) != 0) { 1834 // Caller is asking for component details, so they'd better be 1835 // asking for specific Direct Boot matching behavior 1836 if ((flags & (MATCH_DIRECT_BOOT_UNAWARE 1837 | MATCH_DIRECT_BOOT_AWARE 1838 | MATCH_DIRECT_BOOT_AUTO)) == 0) { 1839 onImplicitDirectBoot(userId); 1840 } 1841 } 1842 return flags; 1843 } From the source code reading of the above aspects, it can also be inferred that when the flag is 0, no additional information about the four major components is obtained. The handling of flags exists in various places within the Android system, but all are based on bitwise AND operations. We can conclude that as long as the flags passed in are 0, the flags used when finally obtaining PackageInfo will also be 0. Obtaining PackageInfo Regarding obtaining PackageInfo, Android 11 introduced a caching mechanism. There's an article that explains this change well: https://juejin.cn/post/7004708493634568200 Apart from the caching mechanism, obtaining PackageInfo can ultimately be traced to the getPackageInfoAsUserUncached() method in PackageManager. private static PackageInfo getPackageInfoAsUserUncached( String packageName, int flags, int userId) { try { return ActivityThread.getPackageManager().getPackageInfo(packageName, flags, userId); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } By reading the code of ActivityThread, it can be determined that PackageInfo is obtained through IPackageManager and is acquired by PackageManagerService. 2345 @UnsupportedAppUsage 2346 public static IPackageManager getPackageManager() { 2347 if (sPackageManager != null) { 2348 return sPackageManager; 2349 } 2350 final IBinder b = ServiceManager.getService(\"package\"); 2351 sPackageManager = IPackageManager.Stub.asInterface(b); 2352 return sPackageManager; 2353 } And in PackageManagerService, the method responsible for obtaining PackageInfo can ultimately be traced to: 3400 protected PackageInfo getPackageInfoInternalBody(String packageName, long versionCode, 3401 int flags, int filterCallingUid, int userId) { 3402 // reader 3403 // Normalize package name to handle renamed packages and static libs 3404 packageName = resolveInternalPackageNameLPr(packageName, versionCode); 3405 3406 final boolean matchFactoryOnly = (flags & MATCH_FACTORY_ONLY) != 0; 3407 if (matchFactoryOnly) { //[When flags=0, it doesn't enter here.] 3408 // Instant app filtering for APEX modules is ignored 3409 if ((flags & MATCH_APEX) != 0) { 3410 return mApexManager.getPackageInfo(packageName, 3411 ApexManager.MATCH_FACTORY_PACKAGE); 3412 } 3413 final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(packageName); 3414 if (ps != null) { 3415 if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) { 3416 return null; 3417 } 3418 if (shouldFilterApplicationLocked(ps, filterCallingUid, userId)) { 3419 return null; 3420 } 3421 return generatePackageInfo(ps, flags, userId); 3422 } 3423 } 3424 3425 AndroidPackage p = mPackages.get(packageName); 3426 if (matchFactoryOnly && p != null && !p.isSystem()) { 3427 return null; 3428 } 3429 if (DEBUG_PACKAGE_INFO) 3430 Log.v(TAG, \"getPackageInfo \" + packageName + \": \" + p); 3431 if (p != null) { 3432 final PackageSetting ps = getPackageSetting(p.getPackageName()); // [the flags will be passed in this block] 3433 if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) { 3434 return null; 3435 } 3436 if (ps != null && shouldFilterApplicationLocked(ps, filterCallingUid, userId)) { 3437 return null; 3438 } 3439 // [the flags will be passed in this block] 3440 return generatePackageInfo(ps, flags, userId); 3441 } // [This part is not entered when the package is found, only consider the method mentioned above for locating.] 3442 if (!matchFactoryOnly && (flags & MATCH_KNOWN_PACKAGES) != 0) { 3443 final PackageSetting ps = mSettings.getPackageLPr(packageName); 3444 if (ps == null) return null; 3445 if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags)) { 3446 return null; 3447 } 3448 if (shouldFilterApplicationLocked(ps, filterCallingUid, userId)) { 3449 return null; 3450 } 3451 return generatePackageInfo(ps, flags, userId); 3452 } 3453 if ((flags & MATCH_APEX) != 0) { 3454 return mApexManager.getPackageInfo(packageName, ApexManager.MATCH_ACTIVE_PACKAGE); 3455 } 3456 return null; 3457 } filterSharedLibPackageLPr is merely a judgment method, and its method comment is: \"Callers can access only the libs they depend on, otherwise they need to explicitly ask for the shared libraries given the caller is allowed to access all static libs.\" The understanding of this is an access control mechanism. Without permission, access to shared libraries is not allowed, and the getPackageInfoInternalBody method will ultimately return a null value. When this permission control mechanism is passed by default, it will ultimately enter the generatePackageInfo(ps, flags, userId) method. private PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) { if (!mUserManager.exists(userId)) return null; if (ps == null) { return null; } final int callingUid = Binder.getCallingUid(); // Filter out ephemeral app metadata: // * The system/shell/root can see metadata for any app // * An installed app can see metadata for 1) other installed apps // and 2) ephemeral apps that have explicitly interacted with it // * Ephemeral apps can only see their own data and exposed installed apps // * Holding a signature permission allows seeing instant apps if (shouldFilterApplicationLocked(ps, callingUid, userId)) { return null; } // [When flags are 0, it won't enter the following section.] if ((flags & MATCH_UNINSTALLED_PACKAGES) != 0 && ps.isSystem()) { flags |= MATCH_ANY_USER; } final PackageUserState state = ps.readUserState(userId); AndroidPackage p = ps.pkg; if (p != null) { final PermissionsState permissionsState = ps.getPermissionsState(); // [When flags are 0, the GID information will not be retrieved.] // Compute GIDs only if requested final int[] gids = (flags & PackageManager.GET_GIDS) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(userId); // Compute granted permissions only if package has requested permissions Set permissions = ArrayUtils.isEmpty(p.getRequestedPermissions()) ? Collections.emptySet() : permissionsState.getPermissions(userId); if (state.instantApp) { permissions = new ArraySet<>(permissions); permissions.removeIf(permissionName -> { BasePermission permission = mPermissionManager.getPermissionTEMP( permissionName); if (permission == null) { return true; } if (!permission.isInstant()) { EventLog.writeEvent(0x534e4554, \"140256621\", UserHandle.getUid(userId, ps.appId), permissionName); return true; } return false; }); } // [the flags will be passed in this block] PackageInfo packageInfo = PackageInfoUtils.generate(p, gids, flags, ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId, ps); if (packageInfo == null) { return null; } packageInfo.packageName = packageInfo.applicationInfo.packageName = resolveExternalPackageNameLPr(p); return packageInfo; // [When PackageInfo is found, it won't enter the following section.] } else if ((flags & MATCH_UNINSTALLED_PACKAGES) != 0 && state.isAvailable(flags)) { PackageInfo pi = new PackageInfo(); pi.packageName = ps.name; pi.setLongVersionCode(ps.versionCode); pi.sharedUserId = (ps.sharedUser != null) ? ps.sharedUser.name : null; pi.firstInstallTime = ps.firstInstallTime; pi.lastUpdateTime = ps.lastUpdateTime; ApplicationInfo ai = new ApplicationInfo(); ai.packageName = ps.name; ai.uid = UserHandle.getUid(userId, ps.appId); ai.primaryCpuAbi = ps.primaryCpuAbiString; ai.secondaryCpuAbi = ps.secondaryCpuAbiString; ai.setVersionCode(ps.versionCode); ai.flags = ps.pkgFlags; ai.privateFlags = ps.pkgPrivateFlags; pi.applicationInfo = PackageParser.generateApplicationInfo(ai, flags, state, userId); if (DEBUG_PACKAGE_INFO) Log.v(TAG, \"ps.pkg is n/a for [\" + ps.name + \"]. Provides a minimum info.\"); return pi; } else { return null; } } Reading PackageInfoUtils will provide the final conclusion. 81 /** 82 * @param pkgSetting See {@link PackageInfoUtils} for description of pkgSetting usage. 83 */ 84 @Nullable 85 public static PackageInfo generate(AndroidPackage pkg, int[] gids, 86 @PackageManager.PackageInfoFlags int flags, long firstInstallTime, long lastUpdateTime, 87 Set grantedPermissions, PackageUserState state, int userId, 88 @Nullable PackageSetting pkgSetting) { 89 return generateWithComponents(pkg, gids, flags, firstInstallTime, lastUpdateTime, 90 grantedPermissions, state, userId, null, pkgSetting); 91 } 92 93 /** 94 * @param pkgSetting See {@link PackageInfoUtils} for description of pkgSetting usage. 95 */ 96 @Nullable 97 public static PackageInfo generate(AndroidPackage pkg, ApexInfo apexInfo, int flags, 98 @Nullable PackageSetting pkgSetting) { 99 return generateWithComponents(pkg, EmptyArray.INT, flags, 0, 0, Collections.emptySet(), 100 new PackageUserState(), UserHandle.getCallingUserId(), apexInfo, pkgSetting); 101 } 102 103 /** 104 * @param pkgSetting See {@link PackageInfoUtils} for description of pkgSetting usage. 105 */ 106 private static PackageInfo generateWithComponents(AndroidPackage pkg, int[] gids, 107 @PackageManager.PackageInfoFlags int flags, long firstInstallTime, long lastUpdateTime, 108 Set grantedPermissions, PackageUserState state, int userId, 109 @Nullable ApexInfo apexInfo, @Nullable PackageSetting pkgSetting) { 110 ApplicationInfo applicationInfo = generateApplicationInfo(pkg, flags, state, userId, 111 pkgSetting); 112 if (applicationInfo == null) { 113 return null; 114 } 115 // [Here, the flags will be passed on.] 116 PackageInfo info = PackageInfoWithoutStateUtils.generateWithoutComponentsUnchecked(pkg, 117 gids, flags, firstInstallTime, lastUpdateTime, grantedPermissions, state, userId, 118 apexInfo, applicationInfo); 119 120 info.isStub = pkg.isStub(); 121 info.coreApp = pkg.isCoreApp(); 122 // [When flags are 0, ACTIVITIES information will not be retrieved.] 123 if ((flags & PackageManager.GET_ACTIVITIES) != 0) { 124 final int N = pkg.getActivities().size(); 125 if (N > 0) { 126 int num = 0; 127 final ActivityInfo[] res = new ActivityInfo[N]; 128 for (int i = 0; i 0) { 146 int num = 0; 147 final ActivityInfo[] res = new ActivityInfo[size]; 148 for (int i = 0; i 0) { 162 int num = 0; 163 final ServiceInfo[] res = new ServiceInfo[size]; 164 for (int i = 0; i 0) { 178 int num = 0; 179 final ProviderInfo[] res = new ProviderInfo[size]; 180 for (int i = 0; i 0) { 195 info.instrumentation = new InstrumentationInfo[N]; 196 for (int i = 0; i Here's the source code of PackageInfoWithoutStateUtils.generateWithoutComponentsUnchecked() 201 /** 202 * This bypasses critical checks that are necessary for usage with data passed outside of 203 * system server. 204 * 205 * Prefer {@link #generateWithoutComponents(ParsingPackageRead, int[], int, long, long, Set, 206 * PackageUserState, int, ApexInfo, ApplicationInfo)}. 207 */ 208 @NonNull 209 public static PackageInfo generateWithoutComponentsUnchecked(ParsingPackageRead pkg, int[] gids, 210 @PackageManager.PackageInfoFlags int flags, long firstInstallTime, long lastUpdateTime, 211 Set grantedPermissions, PackageUserState state, int userId, 212 @Nullable ApexInfo apexInfo, @NonNull ApplicationInfo applicationInfo) { 213 PackageInfo pi = new PackageInfo(); 214 pi.packageName = pkg.getPackageName(); 215 pi.splitNames = pkg.getSplitNames(); 216 pi.versionCode = pkg.getVersionCode(); 217 pi.versionCodeMajor = pkg.getVersionCodeMajor(); 218 pi.baseRevisionCode = pkg.getBaseRevisionCode(); 219 pi.splitRevisionCodes = pkg.getSplitRevisionCodes(); 220 pi.versionName = pkg.getVersionName(); 221 pi.sharedUserId = pkg.getSharedUserId(); 222 pi.sharedUserLabel = pkg.getSharedUserLabel(); 223 pi.applicationInfo = applicationInfo; 224 pi.installLocation = pkg.getInstallLocation(); 225 if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0 226 || (pi.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) { 227 pi.requiredForAllUsers = pkg.isRequiredForAllUsers(); 228 } 229 pi.restrictedAccountType = pkg.getRestrictedAccountType(); 230 pi.requiredAccountType = pkg.getRequiredAccountType(); 231 pi.overlayTarget = pkg.getOverlayTarget(); 232 pi.targetOverlayableName = pkg.getOverlayTargetName(); 233 pi.overlayCategory = pkg.getOverlayCategory(); 234 pi.overlayPriority = pkg.getOverlayPriority(); 235 pi.mOverlayIsStatic = pkg.isOverlayIsStatic(); 236 pi.compileSdkVersion = pkg.getCompileSdkVersion(); 237 pi.compileSdkVersionCodename = pkg.getCompileSdkVersionCodeName(); 238 pi.firstInstallTime = firstInstallTime; 239 pi.lastUpdateTime = lastUpdateTime; // [When flags are 0, GIDS information will not be retrieved.] 240 if ((flags & PackageManager.GET_GIDS) != 0) { 241 pi.gids = gids; 242 } // [When flags are 0, CONFIGURATIONS information will not be retrieved.] 243 if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) { 244 int size = pkg.getConfigPreferences().size(); 245 if (size > 0) { 246 pi.configPreferences = new ConfigurationInfo[size]; 247 pkg.getConfigPreferences().toArray(pi.configPreferences); 248 } 249 size = pkg.getReqFeatures().size(); 250 if (size > 0) { 251 pi.reqFeatures = new FeatureInfo[size]; 252 pkg.getReqFeatures().toArray(pi.reqFeatures); 253 } 254 size = pkg.getFeatureGroups().size(); 255 if (size > 0) { 256 pi.featureGroups = new FeatureGroupInfo[size]; 257 pkg.getFeatureGroups().toArray(pi.featureGroups); 258 } 259 } // [When flags are 0, PERMISSIONS information will not be retrieved.] 260 if ((flags & PackageManager.GET_PERMISSIONS) != 0) { 261 int size = ArrayUtils.size(pkg.getPermissions()); 262 if (size > 0) { 263 pi.permissions = new PermissionInfo[size]; 264 for (int i = 0; i usesPermissions = pkg.getUsesPermissions(); 270 size = usesPermissions.size(); 271 if (size > 0) { 272 pi.requestedPermissions = new String[size]; 273 pi.requestedPermissionsFlags = new int[size]; 274 for (int i = 0; i 0) { 296 pi.attributions = new Attribution[size]; 297 for (int i = 0; i Comments in the PackageInfo Source Code The comments within the PackageInfo source code also indicate that when flags=0, certain information will not be retrieved. 25 /** 26 * Overall information about the contents of a package. This corresponds 27 * to all of the information collected from AndroidManifest.xml. 28 */ 29 public class PackageInfo implements Parcelable { ... 146 /** 147 * All kernel group-IDs that have been assigned to this package. 148 * This is only filled in if the flag {@link PackageManager#GET_GIDS} was set. 149 */ 150 public int[] gids; 151 152 /** 153 * Array of all {@link android.R.styleable#AndroidManifestActivity 154 * &lt;activity&gt;} tags included under &lt;application&gt;, 155 * or null if there were none. This is only filled in if the flag 156 * {@link PackageManager#GET_ACTIVITIES} was set. 157 */ 158 public ActivityInfo[] activities; 159 160 /** 161 * Array of all {@link android.R.styleable#AndroidManifestReceiver 162 * &lt;receiver&gt;} tags included under &lt;application&gt;, 163 * or null if there were none. This is only filled in if the flag 164 * {@link PackageManager#GET_RECEIVERS} was set. 165 */ 166 public ActivityInfo[] receivers; 167 168 /** 169 * Array of all {@link android.R.styleable#AndroidManifestService 170 * &lt;service&gt;} tags included under &lt;application&gt;, 171 * or null if there were none. This is only filled in if the flag 172 * {@link PackageManager#GET_SERVICES} was set. 173 */ 174 public ServiceInfo[] services; 175 176 /** 177 * Array of all {@link android.R.styleable#AndroidManifestProvider 178 * &lt;provider&gt;} tags included under &lt;application&gt;, 179 * or null if there were none. This is only filled in if the flag 180 * {@link PackageManager#GET_PROVIDERS} was set. 181 */ 182 public ProviderInfo[] providers; 183 184 /** 185 * Array of all {@link android.R.styleable#AndroidManifestInstrumentation 186 * &lt;instrumentation&gt;} tags included under &lt;manifest&gt;, 187 * or null if there were none. This is only filled in if the flag 188 * {@link PackageManager#GET_INSTRUMENTATION} was set. 189 */ 190 public InstrumentationInfo[] instrumentation; 191 192 /** 193 * Array of all {@link android.R.styleable#AndroidManifestPermission 194 * &lt;permission&gt;} tags included under &lt;manifest&gt;, 195 * or null if there were none. This is only filled in if the flag 196 * {@link PackageManager#GET_PERMISSIONS} was set. 197 */ 198 public PermissionInfo[] permissions; 199 200 /** 201 * Array of all {@link android.R.styleable#AndroidManifestUsesPermission 202 * &lt;uses-permission&gt;} tags included under &lt;manifest&gt;, 203 * or null if there were none. This is only filled in if the flag 204 * {@link PackageManager#GET_PERMISSIONS} was set. This list includes 205 * all permissions requested, even those that were not granted or known 206 * by the system at install time. 207 */ 208 public String[] requestedPermissions; 209 210 /** 211 * Array of flags of all {@link android.R.styleable#AndroidManifestUsesPermission 212 * &lt;uses-permission&gt;} tags included under &lt;manifest&gt;, 213 * or null if there were none. This is only filled in if the flag 214 * {@link PackageManager#GET_PERMISSIONS} was set. Each value matches 215 * the corresponding entry in {@link #requestedPermissions}, and will have 216 * the flag {@link #REQUESTED_PERMISSION_GRANTED} set as appropriate. 217 */ 218 public int[] requestedPermissionsFlags; 219 220 /** 221 * Array of all {@link android.R.styleable#AndroidManifestAttribution 222 * &lt;attribution&gt;} tags included under &lt;manifest&gt;, or null if there were none. This 223 * is only filled if the flag {@link PackageManager#GET_ATTRIBUTIONS} was set. 224 */ 225 @SuppressWarnings({\"ArrayReturn\", \"NullableCollection\"}) 226 public @Nullable Attribution[] attributions; 227 253 /** 254 * Array of all signatures read from the package file. This is only filled 255 * in if the flag {@link PackageManager#GET_SIGNATURES} was set. A package 256 * must be signed with at least one certificate which is at position zero. 257 * The package can be signed with additional certificates which appear as 258 * subsequent entries. 259 * 260 * Note: Signature ordering is not guaranteed to be 261 * stable which means that a package signed with certificates A and B is 262 * equivalent to being signed with certificates B and A. This means that 263 * in case multiple signatures are reported you cannot assume the one at 264 * the first position to be the same across updates. 265 * 266 * Deprecated This has been replaced by the 267 * {@link PackageInfo#signingInfo} field, which takes into 268 * account signing certificate rotation. For backwards compatibility in 269 * the event of signing certificate rotation, this will return the oldest 270 * reported signing certificate, so that an application will appear to 271 * callers as though no rotation occurred. 272 * 273 * @deprecated use {@code signingInfo} instead 274 */ 275 @Deprecated 276 public Signature[] signatures; 277 278 /** 279 * Signing information read from the package file, potentially 280 * including past signing certificates no longer used after signing 281 * certificate rotation. This is only filled in if 282 * the flag {@link PackageManager#GET_SIGNING_CERTIFICATES} was set. 283 * 284 * Use this field instead of the deprecated {@code signatures} field. 285 * See {@link SigningInfo} for more information on its contents. 286 */ 287 public SigningInfo signingInfo; 288 289 /** 290 * Application specified preferred configuration 291 * {@link android.R.styleable#AndroidManifestUsesConfiguration 292 * &lt;uses-configuration&gt;} tags included under &lt;manifest&gt;, 293 * or null if there were none. This is only filled in if the flag 294 * {@link PackageManager#GET_CONFIGURATIONS} was set. 295 */ 296 public ConfigurationInfo[] configPreferences; 297 Summary When using PackageManager.getPackageInfo(String packageName, int flags), passing in flags as 0 will not retrieve information about the four major components, permissions, gids, etc. You can refer to all flags starting with PackageManager.GET_ to understand that excluding these flags will not fetch the corresponding information. To include multiple flags, you can use the following format: PackageInfo info = packageManager.getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES | PackageManager.GET_PERMISSIONS); When passing flags=0, the basic information included in PackageInfo is: packageName versionCode applicationInfo firstInstallTime lastUpdateTime compileSdkVersion ... Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:22:05 "},"English/[Technique Investigation]/Binder Communication Related.html":{"url":"English/[Technique Investigation]/Binder Communication Related.html","title":"Binder communication related","keywords":"","body":"Topic: How to Handle Calls When Binder Connection is Broken? Further Reading Principles of Android Cross-Process Exception Handling Scenario 1: Service Process is Killed During Method Execution Result: The client triggers a DeadObjectException. If the client does not handle this exception, it may lead to a fatal crash, causing the invocation to be lost. Countermeasure: The client should implement exception handling to ensure it does not crash. Scenario 2: Service Process Throws an Exception Unsupported by AIDL During Method Execution Result: The AIDL method returns default values on the client side. The client does not receive the exception, the service process does not crash, and the Binder connection remains intact. Countermeasure: Avoid throwing exception types in the Binder that cannot be processed across processes. Scenario 3: Service Process Throws an AIDL-Supported Exception During Method Execution Result: The exception is forwarded to the client and can be caught in the method call. The invocation is lost, but the service process does not crash. If the client does not shut down, the Binder connection remains intact. Countermeasure: Avoid throwing exception types in the Binder that cannot be processed across processes. Scenario 4: Binder Connection is Broken Before Method Execution Result: The client triggers a DeadObjectException. If unhandled, it may lead to a fatal crash, causing the invocation to be lost. Countermeasure: In the onServiceDisconnected callback, set the Binder reference to null. All Binder calls must first check if the Binder is null. Topic: Only Nine Exception Types are Supported in Binder Inter-Process Communication In inter-process communication, only the following nine types of exceptions can be transferred between processes: SecurityException BadParcelableException IllegalArgumentException NullPointerException IllegalStateException NetworkOnMainThreadException UnsupportedOperationException ServiceSpecificException Parcelable exceptions For unsupported exceptions, they are handled internally in the program. This may cause crashes, but they will not be passed to the other process. Examples of unsupported exceptions include: Runtime exceptions: RuntimeException Arithmetic exceptions: ArithmeticException Type casting exceptions: ClassCastException Array index out-of-bounds exceptions: ArrayIndexOutOfBoundsException File not found exceptions: FileNotFoundException String-to-number conversion exceptions: NumberFormatException Input/output exceptions: IOException Method not found exceptions: NoSuchMethodException Topic: Why Does Binder Only Require a Single Data Copy? In Linux, processes are isolated and cannot communicate directly. When process A sends data to process B, the data is first copied from the user space of A to the kernel space and then from the kernel space to the user space of B. Binder communication uses the mmap() function to create a memory mapping between the kernel space and the receiving user space's data buffer. This allows process A to copy data directly to the memory buffer mapped to process B's user space, effectively achieving a single data copy. Additionally, as Binder communication is bidirectional, a similar memory mapping is created for the data buffer of process A in the kernel space. Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:22:18 "},"English/[Technique Investigation]/Brief Introduction to MediaSession and Command Transmission and Support.html":{"url":"English/[Technique Investigation]/Brief Introduction to MediaSession and Command Transmission and Support.html","title":"Brief introduction to mediasession and command transmission and support","keywords":"","body":"MediaSession-CS Framework C/S Architecture Defines a standard communication interface between the UI and the player in audio/video applications, achieving complete decoupling between the UI and the player. MediaSession (Server) – Controlled Player Endpoint Manages all communication with the MediaPlayer and hides its APIs from other parts of the application. The system can only access the player through the MediaSession. Maintains information such as: PlaybackState: Player status (e.g., play/pause). MetaData: Related information about the content being played (e.g., title/artist). The MediaSession can receive callbacks from one or more MediaController instances. The response logic to these callbacks must remain consistent, regardless of which client application initiates them. MediaController (Client) The UI communicates solely with the MediaController. It converts transport control operations into callbacks to the MediaSession. Whenever the session state changes, the MediaController receives callbacks from the MediaSession and can update the UI accordingly. A MediaController can connect to only one MediaSession at a time. Creating a MediaController requires a pairing token from the controlled endpoint, which means it should be created only after a successful browser connection. MediaSession Authorization Framework MediaBrowser (Client) Used to connect to the MediaBrowserService and subscribe to data. It allows retrieval of the service connection state and music data via registered callbacks. Typically created on the client side. MediaBrowserService (Server) Contains two key callbacks: onGetRoot: Manages client connection requests and determines whether the client is allowed to connect. onLoadChildren: Triggered when a MediaBrowser sends a data subscription request. This is typically where asynchronous data fetching is performed before sending the data back through the MediaBrowser's registered interface. Command Transmission Client-to-Server Communication Action MediaController.TransportControls MediaSession.Callback Play play() onPlay() Pause pause() onPause() Stop stop() onStop() Seek to Position seekTo(long) onSeekTo(long) Fast Forward fastForward() onFastForward() Rewind rewind() onRewind() Next skipToNext() onSkipToNext() Previous skipToPrevious() onSkipToPrevious() Set Playback Speed setPlaybackSpeed(float) onSetPlaybackSpeed(float) Rate setRating(Rating) onSetRating(Rating) Send Custom Action sendCustomAction(String,Bundle) onSendCustomAction(String,Bundle) Server-to-Client Callbacks Action MediaSession MediaController.Callback Current Track Metadata setMetadata(MediaMetadata) onMetadataChanged(MediaMetadata) Playback State setPlaybackState(PlaybackState) onPlaybackStateChanged(PlaybackState) Playback Queue setQueue(List QueueItem) onQueueChanged(List QueueItem) Queue Title setQueueTitle(CharSequence) onQueueTitleChanged(CharSequence) Extras setExtras(Bundle) onExtrasChanged(Bundle) Command Support Topic 1: Can you determine if the player supports specific commands via code? Conclusion: You can determine support for non-custom commands, but not for custom commands. Example: Checking Supported Non-Custom Commands java复制代码MediaController mediaController = getMediaController(context); if (mediaController != null) { PlaybackState playbackState = mediaController.getPlaybackState(); if (playbackState != null) { long actions = playbackState.getActions(); if ((actions & PlaybackState.ACTION_PLAY) != 0) { Log.d(\"MediaSession\", \"Player supports Play command.\"); } if ((actions & PlaybackState.ACTION_PAUSE) != 0) { Log.d(\"MediaSession\", \"Player supports Pause command.\"); } if ((actions & PlaybackState.ACTION_FAST_FORWARD) != 0) { Log.d(\"MediaSession\", \"Player supports Fast Forward command.\"); } } } Topic 2: Can you determine if the player successfully executed a command via code? Conclusion: You can only determine the success of certain commands (e.g., play/pause) using PlaybackState, but there are no callbacks for commands like next/previous. Example: Checking Command Execution Success java复制代码// Assume a MediaController instance exists MediaController mediaController = ...; // Create and register a Callback to listen for state changes MediaController.Callback callback = new MediaController.Callback() { @Override public void onPlaybackStateChanged(PlaybackState state) { super.onPlaybackStateChanged(state); if (state != null) { int playbackState = state.getState(); switch (playbackState) { case PlaybackState.STATE_PLAYING: Log.d(\"MediaController\", \"Playback started successfully.\"); break; case PlaybackState.STATE_PAUSED: Log.d(\"MediaController\", \"Playback is paused.\"); break; case PlaybackState.STATE_STOPPED: Log.d(\"MediaController\", \"Playback stopped.\"); break; case PlaybackState.STATE_ERROR: Log.e(\"MediaController\", \"Playback error: \" + state.getErrorMessage()); break; default: Log.d(\"MediaController\", \"Playback state changed: \" + playbackState); break; } } } }; // Register the Callback mediaController.registerCallback(callback); // Execute play operation mediaController.getTransportControls().play(); // Unregister the Callback when appropriate // mediaController.unregisterCallback(callback); Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:22:19 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"Summary","keywords":"","body":" English [engineering practice] Setting up gitbook full process and pitfall record [problem solving] The program packaged with pyinstaller that depends on apkutils cannot run [source code reading] [pms] why do downgraded system pre-installed applications revert after a reboot [pm] what does passing 0 to packagemanager.getpackageinfo as a flag mean [technique investigation] Binder communication related Brief introduction to mediasession and command transmission and support Summary _book English [engineering practice] Setting up gitbook full process and pitfall record [source code reading] What does passing 0 to packagemanager.getpackageinfo as a flag mean Gitbook Fonts Fontawesome Gitbook-plugin-accordion Gitbook-plugin-fontsettings Gitbook-plugin-highlight Gitbook-plugin-lunr Gitbook-plugin-search-pro Gitbook-plugin-sharing Gitbook-plugin-tbfed-pagefooter Images 中文 【工程实践】 搭建gitbook全流程及踩坑记录 【源码阅读】 Packagemanager.getpackageinfo()传入0作为flag意味着什么传入0作为Flag意味着什么.md) 中文 【工程实践】 搭建gitbook全流程及踩坑记录 【技术调查】 Binder通信相关 Mediasession简要介绍和命令传递与支持反馈 【源码阅读】 【pms】为什么重启后，被降级的系统内置应用会还原 【pm】packagemanager.getpackageinfo()传入0作为flag意味着什么传入0作为Flag意味着什么.md) 【疑难解决】 Pyinstaller打包依赖apkutils的程序无法运行 Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:30:49 "},"中文/":{"url":"中文/","title":"【工程实践】","keywords":"","body":" 文件索引 README 索引结束 Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:30:50 "},"中文/【工程实践】/搭建Gitbook全流程及踩坑记录.html":{"url":"中文/【工程实践】/搭建Gitbook全流程及踩坑记录.html","title":"搭建gitbook全流程及踩坑记录","keywords":"","body":"这里所有提到的python程序都是自己写的，因为只考虑了自己的需求，没有考虑到其他情况，所以要拷贝使用的话还是根据自己的情况改下比较好 代码位置：https://github.com/Leah-98/Python-Automation/tree/main/Gitbook 将自己的笔记处理成Gitbook最大的好处是可以全局搜索 第一步 准备md笔记仓库 1.将所有文件处理成md，或引用到md文件中 gitbook是只能够渲染markdown页面的。 我之前的笔记里，有一部分比较古早的笔记来自evernote、有道云的导出，是网页格式。网页格式我就转成PDF了，引用写在除了根目录的README.md文件夹下（append_other_files_to_readme.py）。 还有些零零散散的txt笔记，就直接将后缀改成md了（txt_to_md.py） 2.将md引用的图片放置在md文件的同级目录的子文件夹下，子文件夹命名为md文件的名字_imgs 之前的笔记引用图片比较混乱，有的是网络图片，有的是typora帮我写了绝对路径，但是在各个电脑上操作同一个笔记仓库，绝对路径不一致，有的以相对路径放在imgs文件夹下，但imgs文件夹在笔记仓库的各个位置，也比较乱。 还是用python程序处理，统一放置到md文件的同级目录的子文件夹下，子文件夹命名为md文件的名字_imgs，md里的图片引用重写为相对路径（reformat_imgs.py） 另外我自己的书摘很多时候是直接拍的实体书，手机照片太大了，需要压缩下（compress_pictures.py） 3.生成SUMMARY.md 将所有的md文件按文件路径写好SUMMARY.md，如果是子文件夹且没有README.md，则自己创建一个（generate_summary.py） 比gitbook init会好用一些，gitbook init生成文件有各种bug，且没办法根据所有md文件生成summary 第二步 准备Gitbook搭建环境 直接看的网络上的教程，踩了一堆坑。 这个教程太简单了，可以先看一遍了解一下大概，但不要按里面的流程走 https://tonydeng.github.io/gitbook-zh/ 这个更详细更好 https://1927344728.github.io/fed-knowledge/tools/Gitbook/ 0.踩坑前置 刚开始直接去官网下载安装的 官网：https://nodejs.org/en 但是官网这个版本(v18.x)太新了，gitbook有各种适配问题，后来降级成(v.10.x才正常使用gitbook) 讲一下踩坑过程吧，使用v18.x版本的nodejs，安装gitbook-cli后，在命令行调用gitbook init，报错： /home/travis/.nvm/versions/node/v12.18.3/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /home/travis/.nvm/versions/node/v12.18.3/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:169:5) 解决方法：https://stackoverflow.com/questions/64211386/gitbook-cli-install-error-typeerror-cb-apply-is-not-a-function-inside-graceful 需要更新下graceful-fs版本 我使用npm更新的时候还踩了个坑，调用任何命令都是报错 ERR! Cannot read property 'insert' of undefined 解决方法：https://github.com/npm/cli/issues/4876 就是需要修改镜像到https://registry.npmmirror.com 如果还需要设置proxy的话，这里有教程 npm设置代理：https://blog.csdn.net/yanzi1225627/article/details/80247758 更新完之后，gitbook 调用任何命令没有反应，没有报错没有任何信息，本地目录没有任何变化，之后就将nodejs降级成了10.x 期间还有一个坑，gitbook和gitbook-cli是不能共存的，使用gitbook-cli(gitbook的命令行工具)得把gitbook卸载掉，安装完gitbook-cli第一次调用gitbook命令时，gitbook -V这种看版本号的也算，gitbook-cli就会去安装对应版本的gitbook 因为我每次调用gitbook命令，都会卡在install gitbook这一步，查了下网上的方法，可以克隆gitbook的github仓库然后自己install自己link git clone https://github.com/GitbookIO/gitbook.git cd gitbook npm install npm link 首先gitbook仓库里面的说明是使用bun安装而不是npm，其次这样安装还是相当于npm install gitbook，gitbook和gitbook-cli是冲突的，所以这个方法是错的。 下面说正确的方法 1.安装nvm(nodejs的版本管理工具)和10.x版本的nodejs 根据自己系统的情况二者选一 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash bash Copy code wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 安装nodejs 10.x版本并使用 nvm install 10 nvm use 10 这里还踩了个坑，上面的步骤中会安装nodejs 10.x版本适配的npm，但是我之前使用的18.x版本，切换使用nodejs 10.x版本后，npm的版本没有切换，调用npm任何命令都会报错，后来且切换回使用18版本，再卸载npm，这里的卸载操作会卸载最新版本npm，切换使用10.x版本后，就能正常使用到较低版本的npm了 nvm use 18 npm uninstall npm -g -g的意思是将操作实施到全局，这个命令之后也会用到 2.安装使用gitbook-cli&gitbook npm install gitbook-cli -g npm install -g 命令用于全局安装 Node.js 模块。这意味着安装的模块将被放置在一个特定的目录中，通常是你的系统的全局 node_modules 目录下，而不是当前项目的 node_modules 目录下。 如果在 npm install 命令中不使用 -g（全局）参数，那么该命令将会在当前项目目录下的 node_modules 文件夹中安装指定的包，而不是在全局环境中安装。 gitbook -V 查看gitbook版本，第一次调用任何gitbook命令会去安装gitbook 再次运行gitbook -V可以看到gitbook-cli和gitbook的版本 注意不要自己npm install gitbook，要通过gitbook-cli 3.预览gitbook网站，进行修复 将命令行切换到自己的自己的md源文件根目录下，运行下面的命令自动生成README.md、SUMMARY.md 建议跑脚本，gitbook init生成文件有各种bug，且没办法根据所有md文件生成summary gitbook init 注意目录下md文件和子文件不要包含“#”这个字符，也就是说生成的SUMMARY.md引用中不要有“#”字符，如果有的话会导致生成的gitbook页面点击左部的相应导航条目无法跳转 另外md文件中任何位置不要有连续的大括号，比如 相关说明：https://wkcom.gitee.io/gitbook%E7%9A%84%E4%BD%BF%E7%94%A8/3%E3%80%81gitbook%E8%BF%9E%E7%BB%AD%E5%A4%A7%E6%8B%AC%E5%8F%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html 大括号中间加个空格就能解决 预览gitbook网站 gitbook server 在浏览器打开本地端口page查看 http://localhost:4000/ 第三步 搭建.io在线网站 有很多解决方案，我选择直接在Github上传静态网站。 生成gitbook静态网站，在自己的md源文件根目录下运行： gitbook build 会生成个_book目录，里面放置的就是静态网站代码 只要仓库里有gh-pages分支，就可以根据下面的连接访问Gitbook Pages https://githubusername.github.io/reponame 所以步骤就是： 创建个空的github仓库 切出个gh-pages分支，上传静态网站 我需要多个gitbook，所以我在根目录下创建个子文件夹，在这个子文件夹下上传对应的静态网站 那我就可以根据下面路径访问多个Gitbook https://githubusername.github.io/reponame/subfoldername1 https://githubusername.github.io/reponame/subfoldername2 Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-04-12 18:40:21 "},"中文/【技术调查】/Binder通信相关.html":{"url":"中文/【技术调查】/Binder通信相关.html","title":"Binder通信相关","keywords":"","body":"议题：Binder断联的情况下，调用如何处理？ 拓展阅读：Android跨进程抛异常的原理的实现 情况1：执行方法的过程中Service端进程被杀死 结果：Client端触发DeadObjectException，如Client端未作异常处理会导致其Fatal Crash，调用丢失 对策：由Client端做异常处理，至少保证Client端不Crash 情况2：执行方法的过程中Service端进程抛出Aidl不支持的Exception 结果：Aidl方法在Client端返回默认值，Client端没有接收到异常，Service端不会Crash，Binder不会断联 对策：在Binder中不应抛出不支持跨进程处理的异常类型 情况3：执行方法的过程中Service端进程抛出Aidl支持的Exception 结果：Exception被转递给Client，在方法调用中可以catch Exception，调用丢失，Service端不会Crash，Client不shutdown的情况下Binder不会断联 对策：在Binder中不应抛出不支持跨进程处理的异常类型 情况4：执行方法前，Binder连接已经断联 结果：Client端触发DeadObjectException，如未作异常处理会导致Fatal Crash，调用丢失 对策：onServiceDisConnected回调中应该将Binder置空，所有对Binder的调用必须先判断Binder是否为null 议题：Binder支持在进程间转递的异常只有九种 1、跨进程通讯中，从一端到另外一端，只支持传递以下9种异常: SecurityException BadParcelableException IllegalArgumentException NullPointerException IllegalStateException NetworkOnMainThreadException UnsupportedOperationException ServiceSpecificException Parcelable的异常 2、对于不支持的异常，会在程序内部处理，可能导致崩溃，但不会传递给对方。常见的不支持的异常， 运行时异常：RuntimeException 算术异常类：ArithmeticExecption 类型强制转换异常：ClassCastException 数组下标越界异常：ArrayIndexOutOfBoundsException 文件未找到异常：FileNotFoundException 字符串转换为数字异常：NumberFormatException 输入输出异常：IOException 方法未找到异常：NoSuchMethodException 议题：为什么Binder通信只需要拷贝一次数据？ Linux中的进程是被隔离不能直接进行通信的，A进程向B进程传递数据，需要先将数据从A的用户空间拷贝到内核空间，然后从内核空间拷贝到B的用户空间。 Binder通信采用了mmap()函数，将内核空间和接收方用户空间的数据缓存区之间做了一层内存映射，这样，A进程向B进程传递数据，只需要从A的用户空间拷贝到B的用户空间数据缓存区在内核空间中的内存映射，就相当于直接拷贝到了B的用户空间。 由于Binder是双向通信，还会有A的用户空间数据缓存区在内核空间中的内存映射 Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:28:32 "},"中文/【技术调查】/MediaSession简要介绍和命令传递与支持反馈.html":{"url":"中文/【技术调查】/MediaSession简要介绍和命令传递与支持反馈.html","title":"Mediasession简要介绍和命令传递与支持反馈","keywords":"","body":"MediaSession-CS框架 C/S架构 规范了音视频应用中界面与播放器之间的通信接口，实现界面与播放器之间的完全解耦。 MediaSession媒体会话（Server）播放器受控端 负责与MediaPlayer播放器的所有通信，对应用的其它部分隐藏播放器的API，系统只能从控制播放器的MediaSession中调用播放器。 维持的信息：PlaybackState-播放器状态（播放/暂停），MetaData-播放内容的相关信息（标题/音乐家）。 MediaSession可以接收来自一个或多个MediaController的回调，响应回调的逻辑必须保持一致，无论哪个客户端应用发起了回调，对回调的响应都是相同的。 MediaController媒体控制器（Client） 界面的代码只与MediaController通信，MediaController会将传输控制操作转换为对媒体会话的回调。每当会话状态发生变化时，它也会接收来自媒体会话的回调，这时便可以更新界面。 MediaController一次只能连接到一个MediaSession MediaController 创建时需要受控端的配对令牌，因此需要在浏览器连接成功后才进行 MediaController 的创建。 MediaSession-授权框架 MediaBrowser媒体浏览器（Client） 用来连接媒体服务MediaBrowserService和订阅数据，在注册的回调接口中可以获取到Service的连接状态、获取音乐数据，一般在客户端中创建。 MediaBrowserService媒体服务（Server） 它有两个关键的回调函数，onGetRoot（控制客户端MediaBrowser的连接请求，返回值中决定是否允许连接）,onLoadChildren（MediaBrowser向服务器发送数据订阅请求时会被调用，一般在这里执行异步获取数据的操作，然后在将数据发送回MediaBrowser注册的接口中）。 命令传递 客户端调用服务器 意义 MediaController.TransportControls MediaSession.Callback 播放 play() onPlay() 暂停 pause() onPause() 停止 stop() onStop() 指定播放位置 seekTo(long) onSeekTo(long) 快进 fastForward() onFastForward() 回倒 rewind() onRewind() 下一首 skipToNext() onSkipToNext() 上一首 skipToPrevious() onSkipToPrevious() 设置播放速度 setPlaybackSpeed(float) onSetPlaybackSpeed(float) 打分 setRating(Rating) onSetRating(Rating) 发送自定义动作 sendCustomAction(String,Bundle) onSendCustomAction(String,Bundle) 服务端回调给客户端 意义 MediaSession MediaController.Callback 当前播放音乐 setMetadata(MediaMetadata) onMetadataChanged(MediaMetadata) 播放状态 setPlaybackState(PlaybackState) onPlaybackStateChanged(PlaybackState) 播放队列 setQueue(List MediaSession.QueueItem) onQueueChanged(List MediaSession.QueueItem) 播放队列标题 setQueueTitle(CharSequence) onQueueTitleChanged(CharSequence) 额外信息 setExtras(Bundle) onExtrasChanged(Bundle) 命令支持 议题1：能否通过代码知道播放器是否支持某些操作指令 结论：可以知道非自定义的指令是否支持，但自定义指令不可以 获取非自定义指令是否支持的代码示例： MediaController mediaController = getMediaController(context); if (null != mediaController) { // 获取当前的 PlaybackState PlaybackState playbackState = mediaController.getPlaybackState(); if (playbackState != null) { // 获取支持的操作 long actions = playbackState.getActions(); // 检查播放器是否支持播放 if ((actions & PlaybackState.ACTION_PLAY) != 0) { Log.d(\"MediaSession\", \"播放器支持播放操作\"); } // 检查播放器是否支持暂停 if ((actions & PlaybackState.ACTION_PAUSE) != 0) { Log.d(\"MediaSession\", \"播放器支持暂停操作\"); } // 检查播放器是否支持快进 if ((actions & PlaybackState.ACTION_FAST_FORWARD) != 0) { Log.d(\"MediaSession\", \"播放器支持快进操作\"); } } } 议题2：能否通过代码知道播放器是否成功完成了指令 结论：只能知道部分指令是否成功执行，暂停\\继续播放等可以通过PlaybackState判断，但上一首\\下一首等没有相应的Callback 获取部分指令是否成功执行的代码示例： // 假设已经有一个 MediaController 实例 MediaController mediaController = ...; // 创建并注册一个 Callback 来监听播放状态的变化 MediaController.Callback callback = new MediaController.Callback() { @Override public void onPlaybackStateChanged(PlaybackState state) { super.onPlaybackStateChanged(state); if (state != null) { int playbackState = state.getState(); switch (playbackState) { case PlaybackState.STATE_PLAYING: Log.d(\"MediaController\", \"Playback started successfully.\"); break; case PlaybackState.STATE_PAUSED: Log.d(\"MediaController\", \"Playback is paused.\"); break; case PlaybackState.STATE_STOPPED: Log.d(\"MediaController\", \"Playback stopped.\"); break; case PlaybackState.STATE_ERROR: Log.e(\"MediaController\", \"Playback encountered an error: \" + state.getErrorMessage()); break; // 其他状态可以根据需要处理 default: Log.d(\"MediaController\", \"Playback state changed: \" + playbackState); break; } } } }; // 注册 Callback mediaController.registerCallback(callback); // 执行播放操作 mediaController.getTransportControls().play(); // 在适当的时候注销 Callback // mediaController.unregisterCallback(callback); Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:30:43 "},"中文/【源码阅读】/【PMS】为什么重启后，被降级的系统内置应用会还原.html":{"url":"中文/【源码阅读】/【PMS】为什么重启后，被降级的系统内置应用会还原.html","title":"【pms】为什么重启后，被降级的系统内置应用会还原","keywords":"","body":"背景 系统内置应用是预装在 /system 分区中的应用，它们通常被标记为只读且版本由系统更新决定。但在运行过程中，用户可能会安装新版本的系统内置应用（位于 /data 分区），甚至将其降级到比 /system 中版本更低的状态。然而，当系统重启后，如果 /data 分区的版本低于 /system 分区中的版本，系统会自动还原到 /system 分区的版本。 代码解读 可以直接找到 frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java Line 12162 ~ 12186的源码 // 比较 VersionCode，当/data下的VersionCode更低时进入此分支 if (isSystemPkgBetter) { // The version of the application on /system is greater than the version on // /data. Switch back to the application on /system. // It's safe to assume the application on /system will correctly scan. If not, // there won't be a working copy of the application. synchronized (mLock) { // just remove the loaded entries from package lists mPackages.remove(pkgSetting.name); } logCriticalInfo(Log.WARN, \"System package updated;\" + \" name: \" + pkgSetting.name + \"; \" + pkgSetting.versionCode + \" --> \" + parsedPackage.getLongVersionCode() + \"; \" + pkgSetting.getPathString() + \" --> \" + parsedPackage.getPath()); final InstallArgs args = createInstallArgsForExisting( pkgSetting.getPathString(), getAppDexInstructionSets( pkgSetting.primaryCpuAbiString, pkgSetting.secondaryCpuAbiString)); args.cleanUpResourcesLI(); // 还原并启用 `/system` 分区版本 synchronized (mLock) { mSettings.enableSystemPackageLPw(pkgSetting.name); } } Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-11-26 16:25:19 "},"中文/【疑难解决】/pyinstaller打包依赖apkutils的程序无法运行.html":{"url":"中文/【疑难解决】/pyinstaller打包依赖apkutils的程序无法运行.html","title":"Pyinstaller打包依赖apkutils的程序无法运行","keywords":"","body":"运行exe时报错如下： Traceback (most recent call last): File \"create_release_jira.py\", line 47, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"submit_gerrit.py\", line 48, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"mandroid.py\", line 1, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\__init__.py\", line 1, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\apk.py\", line 12, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\axml\\__init__.py\", line 12, in File \"\", line 1176, in _find_and_load File \"\", line 1147, in _find_and_load_unlocked File \"\", line 690, in _load_unlocked File \"PyInstaller\\loader\\pyimod02_importers.py\", line 391, in exec_module File \"apkutils\\axml\\public.py\", line 22, in Exception: need to copy the sdk/platforms/android-?/data/res/values/public.xml here [6428] Failed to execute script 'create_release_jira' due to unhandled exception! 用最后这一条报错Exception: need to copy the sdk/platforms/android-?/data/res/values/public.xml here 在网上搜到的信息：https://github.com/Nuitka/Nuitka/issues/2289 人家是通过添加yaml配置解决的： Fixed with a custom package config - module-name: \"apkutils.axml\" data-files: patterns: - \"public.xml\" 说明问题在于apkutils找不到public.xml。 可以找到本机的site-packages目录，这个public.xml是apkutils自身的依赖数据 报错也是public.py抛出的，即public.py希望同路径下有public.xml文件 虽然我们使用pyinstaller无法配置yaml，但利用--add-data命令也可以实现一样的效果 在pyinstaller命令中增加配置就可以了，如下： pyinstaller --add-data=\"F:\\.dev\\PYTHON\\Lib\\site-packages\\apkutils\\axml\\public.xml;apkutils/axml\" py源文件.py Copyright © Leah 2024 all right reserved，powered by Gitbookmodified time: 2024-12-11 15:22:23 "}}